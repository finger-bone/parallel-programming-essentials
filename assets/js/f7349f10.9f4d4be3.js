"use strict";(self.webpackChunknotes_template=self.webpackChunknotes_template||[]).push([[2277],{76:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"sycl/first-step","title":"First Step into SYCL","description":"This note book provides introduction to parallel programming. Because this book focuses more on the algorithmic aspects of parallel programming, we use SYCL instead of OpenCL or OpenMP because SYCL is a higher level programming model that is easier to understand and use.","source":"@site/docs/sycl/first-step.md","sourceDirName":"sycl","slug":"/sycl/first-step","permalink":"/parallel-programming-essentials/docs/sycl/first-step","draft":false,"unlisted":false,"editUrl":"https://github.com/finger-bone/parallel-programming-essentials/blob/main/docs/sycl/first-step.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"SYCL Quickstart","permalink":"/parallel-programming-essentials/docs/category/sycl-quickstart"},"next":{"title":"Tutorial - Basics","permalink":"/parallel-programming-essentials/docs/category/tutorial---basics"}}');var o=s(4848),c=s(8453);const i={sidebar_position:1},a="First Step into SYCL",r={},l=[{value:"What is SYCL?",id:"what-is-sycl",level:2},{value:"Run the First SYCL Program",id:"run-the-first-sycl-program",level:2},{value:"Where Code Executes",id:"where-code-executes",level:2},{value:"Action Graph",id:"action-graph",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",mermaid:"mermaid",p:"p",pre:"pre",...(0,c.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"first-step-into-sycl",children:"First Step into SYCL"})}),"\n",(0,o.jsx)(n.p,{children:"This note book provides introduction to parallel programming. Because this book focuses more on the algorithmic aspects of parallel programming, we use SYCL instead of OpenCL or OpenMP because SYCL is a higher level programming model that is easier to understand and use."}),"\n",(0,o.jsx)(n.h2,{id:"what-is-sycl",children:"What is SYCL?"}),"\n",(0,o.jsx)(n.p,{children:'SYCL is a C++ programming model that enables code for heterogeneous processors to be written in a "single-source" style using completely standard C++.'}),"\n",(0,o.jsx)(n.p,{children:"Compared with OpenCL, SYCL is a bit higher level but very easy to use."}),"\n",(0,o.jsx)(n.p,{children:"SYCL could use OpenCL, CUDA or other backend."}),"\n",(0,o.jsx)(n.h2,{id:"run-the-first-sycl-program",children:"Run the First SYCL Program"}),"\n",(0,o.jsxs)(n.p,{children:["You need to install the oneAPI toolkit. You can download it from the ",(0,o.jsx)(n.a,{href:"https://software.intel.com/content/www/us/en/develop/tools/oneapi/base-toolkit.html",children:"Intel website"}),". Or alternatively, use AdaptiveCPP compiler."]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)("summary",{children:"Docker Environment for Mac Users and Lazy People"}),(0,o.jsx)(n.p,{children:"If you are using a Mac like me, unfortunately, the oneAPI DPC++ dropped support for MacOS a while ago. Of course, you can compile and run AdaptiveCpp. But we tool kit from Intel provides more features."}),(0,o.jsx)(n.p,{children:"Of course, you can run linux virtual machine. But an easier approach would be to use docker."}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"services:\n  hpc:\n    image: intel/hpckit\n    platform: linux/amd64\n    volumes:\n      - ./code:/code\n    stdin_open: true\n    tty: true\n    command: /bin/bash\n"})}),(0,o.jsx)(n.p,{children:"Then you can attach vscode to the docker and use it as your environment (Yes, Rosetta is that magical)."})]}),"\n",(0,o.jsx)(n.p,{children:"We write our first program as a demonstration. You don't need to understand any of the code. Just copy paste and run it."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include <sycl/sycl.hpp>\n\nclass vector_addition;\n\nint main(int, char**) {\n    sycl::float4 a = { 1.0, 2.0, 3.0, 4.0 };\n    sycl::float4 b = { 4.0, 3.0, 2.0, 1.0 };\n    sycl::float4 c = { 0.0, 0.0, 0.0, 0.0 };\n\n    auto device_selector = sycl::default_selector_v;\n\n    sycl::queue queue(device_selector);\n    \n    std::cout << "Running on: "\n              << queue.get_device().get_info<sycl::info::device::name>()\n              << "\\n";\n\n    {\n        sycl::buffer<sycl::float4, 1> a_sycl(&a, sycl::range<1>(1));\n        sycl::buffer<sycl::float4, 1> b_sycl(&b, sycl::range<1>(1));\n        sycl::buffer<sycl::float4, 1> c_sycl(&c, sycl::range<1>(1));\n\n        queue.submit([&] (sycl::handler& cgh) {\n            auto a_acc = a_sycl.get_access<sycl::access::mode::read>(cgh);\n            auto b_acc = b_sycl.get_access<sycl::access::mode::read>(cgh);\n            auto c_acc = c_sycl.get_access<sycl::access::mode::discard_write>(cgh);\n\n            cgh.single_task<class vector_addition>([=] () {\n                c_acc[0] = a_acc[0] + b_acc[0];\n            });\n        });\n    }\n    std::cout << "  A { " << a.x() << ", " << a.y() << ", " << a.z() << ", " << a.w() << " }\\n"\n              << "+ B { " << b.x() << ", " << b.y() << ", " << b.z() << ", " << b.w() << " }\\n"\n              << "==================\\n"\n              << "= C { " << c.x() << ", " << c.y() << ", " << c.z() << ", " << c.w() << " }"\n              << std::endl;\n\n    return 0;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Use the command,"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"icpx -fsycl ./first_step.cc\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To compile. ",(0,o.jsx)(n.code,{children:"icpx"})," is the Intel compiler. ",(0,o.jsx)(n.code,{children:"-fsycl"})," is the flag to enable SYCL. The output is ",(0,o.jsx)(n.code,{children:"a.out"}),". Run it with ",(0,o.jsx)(n.code,{children:"./a.out"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"You should see the output,"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"Running on: VirtualApple @ 2.50GHz\n  A { 1, 2, 3, 4 }\n+ B { 4, 3, 2, 1 }\n==================\n= C { 5, 5, 5, 5 }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Running on: VirtualApple @ 2.50GHz"})," is the name of the device. It may vary depending on the device you are using."]}),"\n",(0,o.jsx)(n.p,{children:"If you ever learnt OpenCL before, you will find the code soothing- not as scary as OpenCL."}),"\n",(0,o.jsxs)(n.p,{children:["For this part, you need to know how to compile and use the header ",(0,o.jsx)(n.code,{children:"sycl/sycl.hpp"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"where-code-executes",children:"Where Code Executes"}),"\n",(0,o.jsx)(n.p,{children:"Unlike OpenCL, SYCL uses a single source. So you should be clear about where your code is running on- by that, we mean, if it is running on your host computer, or the device."}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsx)(n.p,{children:"By the host computer, we mean the, well, physical computer you are using. By the device, we mean a part of your computer that is capable of large parallel computation. Typically, it is GPU. But if, for example, you are using Xeon-level processors, the host and device may be the same."}),(0,o.jsx)(n.p,{children:"In the following parts of this note, a device always refer to the device that handles large parallel computation."})]}),"\n",(0,o.jsx)(n.p,{children:"The host interacts with the device via command queues. This is a queue on the device that stores commands. The host can submit commands to the queue, and the device will execute them in order."}),"\n",(0,o.jsx)(n.p,{children:"Again, SYCL is single source, thus you must know where your code is going. It is simple: If you are using SYCL specific API to order the device to do something, then it is device code. Otherwise, it is host code."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// host code\n\ndevice.submit([&] (sycl::handler& cgh) {\n    cgh.host_task([=] () {\n        // host code\n    });\n    cgh.parallel_for<class my_kernel>(range, [=] (sycl::id<1> idx) {\n        // device code\n    });\n});\n\n// host code\n"})}),"\n",(0,o.jsx)(n.mermaid,{value:"graph LR\n    A[SYCL Code] --\x3e|Host Code| B[Executed by the Host]\n    A --\x3e|Device Code| D[Command Queue]\n    D --\x3e E[Executed By Device]"}),"\n",(0,o.jsx)(n.p,{children:"Device code are executed asynchronously from the host code. Thus you need synchronization if you need the result."}),"\n",(0,o.jsx)(n.p,{children:"Host code and device code are fundamentally different. If you ever learnt OpenCL, you can tell that. Thanks to the job done by SYCL dev team, we can write modern C++ for device code. And albeit it runs, you should not use things like dynamic memory allocation, exceptions, etc. in device code. Because most of the time, the device is something like GPU that doesn't support these features."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"When we debug, we usually choose CPU as the device because debugging on CPU is much easier than debugging on GPU."})}),"\n",(0,o.jsxs)(n.p,{children:["To select a device, use the ",(0,o.jsx)(n.code,{children:"sycl::default_selector_v"})," as we did in the first program. It will select the default device. You can also use ",(0,o.jsx)(n.code,{children:"sycl::cpu_selector_v"})," or ",(0,o.jsx)(n.code,{children:"sycl::gpu_selector_v"})," to select CPU or GPU."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto device_selector = sycl::default_selector_v;\nsycl::queue queue{device_selector};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"action-graph",children:"Action Graph"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"q.submit"})," does not really submit the command to the device."]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);