"use strict";(self.webpackChunknotes_template=self.webpackChunknotes_template||[]).push([[4326],{2666:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"sycl/exception","title":"Exception in SYCL","description":"Errors, what we hate but can\'t avoid. If you ever tried to debug an OpenCL program, you know how painful it is. However, SYCL offers C++ exception handling for host code, which is a bit of a blessing.","source":"@site/docs/sycl/exception.mdx","sourceDirName":"sycl","slug":"/sycl/exception","permalink":"/parallel-programming-essentials/docs/sycl/exception","draft":false,"unlisted":false,"editUrl":"https://github.com/finger-bone/parallel-programming-essentials/blob/main/docs/sycl/exception.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Basic Kernel","permalink":"/parallel-programming-essentials/docs/sycl/basic-kernel"},"next":{"title":"Parallel Patterns","permalink":"/parallel-programming-essentials/docs/parallel-patterns"}}');var o=t(4848),i=t(8453);const r={sidebar_position:4},a="Exception in SYCL",c={},l=[{value:"Synchronous Exceptions",id:"synchronous-exceptions",level:2},{value:"Asynchronous Exceptions",id:"asynchronous-exceptions",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"exception-in-sycl",children:"Exception in SYCL"})}),"\n",(0,o.jsx)(n.p,{children:"Errors, what we hate but can't avoid. If you ever tried to debug an OpenCL program, you know how painful it is. However, SYCL offers C++ exception handling for host code, which is a bit of a blessing."}),"\n",(0,o.jsx)(n.p,{children:"Parallel computation device don't have exception mechanism because it impedes the parallelism."}),"\n",(0,o.jsx)(n.h2,{id:"synchronous-exceptions",children:"Synchronous Exceptions"}),"\n",(0,o.jsxs)(n.p,{children:["Synchronous exceptions are identical to the standard C++ exception, just of type ",(0,o.jsx)(n.code,{children:"sycl::exception"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"asynchronous-exceptions",children:"Asynchronous Exceptions"}),"\n",(0,o.jsx)(n.p,{children:"Asynchronous Exceptions are exceptions thrown within the host task in the action graph."}),"\n",(0,o.jsx)(n.p,{children:"You need a handler to deal with that- and that's it."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <sycl/sycl.hpp>\nusing namespace sycl;\n\n// Our example asynchronous handler function\nauto handle_async_error = [](exception_list elist) {\n    for (auto &e : elist) {\n        try {\n            std::rethrow_exception(e);\n        } catch (...) {\n            std::cout << "Caught SYCL ASYNC exception!!\\n";\n        }\n    }\n};\n\nvoid say_device(const queue &Q) {\n    std::cout << "Device : "\n              << Q.get_device().get_info<info::device::name>()\n              << "\\n";\n}\n\nclass something_went_wrong {}; // Example exception type\n\nint main() {\n    queue q{cpu_selector_v, handle_async_error};\n    say_device(q);\n\n    q.submit([&](handler &h) {\n        h.host_task([&]() { throw something_went_wrong{}; });\n    }).wait();\n\n    return 0;\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}}}]);