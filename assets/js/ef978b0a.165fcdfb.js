"use strict";(self.webpackChunknotes_template=self.webpackChunknotes_template||[]).push([[4885],{1115:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"SYCL Quickstart","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"First Step into SYCL","href":"/parallel-programming-essentials/docs/sycl/first-step","docId":"sycl/first-step","unlisted":false},{"type":"link","label":"Memory","href":"/parallel-programming-essentials/docs/sycl/memory","docId":"sycl/memory","unlisted":false},{"type":"link","label":"Basic Kernel","href":"/parallel-programming-essentials/docs/sycl/basic-kernel","docId":"sycl/basic-kernel","unlisted":false},{"type":"link","label":"Exception in SYCL","href":"/parallel-programming-essentials/docs/sycl/exception","docId":"sycl/exception","unlisted":false}],"href":"/parallel-programming-essentials/docs/category/sycl-quickstart"},{"type":"link","label":"Parallel Patterns","href":"/parallel-programming-essentials/docs/parallel-patterns","docId":"parallel-patterns","unlisted":false},{"type":"link","label":"Parallel Prefix Sum","href":"/parallel-programming-essentials/docs/parallel-prefix-sum","docId":"parallel-prefix-sum","unlisted":false},{"type":"category","label":"Parallel Sorting","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Parallel Merge Sort","href":"/parallel-programming-essentials/docs/parallel-sorting/merge-sort","docId":"parallel-sorting/merge-sort","unlisted":false},{"type":"link","label":"Bitonic Sort","href":"/parallel-programming-essentials/docs/parallel-sorting/bitonic-sort","docId":"parallel-sorting/bitonic-sort","unlisted":false}],"href":"/parallel-programming-essentials/docs/category/parallel-sorting"},{"type":"category","label":"ND Kernel","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Device Coarse Architecture","href":"/parallel-programming-essentials/docs/nd-kernel/device-coarse-architecture","docId":"nd-kernel/device-coarse-architecture","unlisted":false},{"type":"link","label":"Work Distribution","href":"/parallel-programming-essentials/docs/nd-kernel/work-distribution","docId":"nd-kernel/work-distribution","unlisted":false}],"href":"/parallel-programming-essentials/docs/category/nd-kernel"}]},"docs":{"nd-kernel/device-coarse-architecture":{"id":"nd-kernel/device-coarse-architecture","title":"Device Coarse Architecture","description":"Before introducing the ND kernel, we must take a look at how our devices work.","sidebar":"tutorialSidebar"},"nd-kernel/work-distribution":{"id":"nd-kernel/work-distribution","title":"Work Distribution","description":"","sidebar":"tutorialSidebar"},"parallel-patterns":{"id":"parallel-patterns","title":"Parallel Patterns","description":"Parallel patterns are fundamental building blocks in parallel programming, similar to how design patterns work in object-oriented programming. These patterns provide proven solutions to common parallel programming challenges.","sidebar":"tutorialSidebar"},"parallel-prefix-sum":{"id":"parallel-prefix-sum","title":"Parallel Prefix Sum","description":"Prefix Sum si a classical problem in computer science. Given an array of numbers, we want to compute the sum of each prefix of the array. For example, given the array [1, 2, 3, 4, 5], the prefix sum is [1, 3, 6, 10, 15].","sidebar":"tutorialSidebar"},"parallel-sorting/bitonic-sort":{"id":"parallel-sorting/bitonic-sort","title":"Bitonic Sort","description":"Bitonic Sort is an algorithm designed based on merge sort. It is capable of achieving $O((\\\\log n)^2)$ complexity.","sidebar":"tutorialSidebar"},"parallel-sorting/merge-sort":{"id":"parallel-sorting/merge-sort","title":"Parallel Merge Sort","description":"Divide and conquer are all reduce pattern. And thus, when it comes to parallel sorting, the first thing we come to is the merge sort as a parallel divide-and-conquer.","sidebar":"tutorialSidebar"},"sycl/basic-kernel":{"id":"sycl/basic-kernel","title":"Basic Kernel","description":"A kernel is a task that is distributed to each processing element on a computation device.","sidebar":"tutorialSidebar"},"sycl/exception":{"id":"sycl/exception","title":"Exception in SYCL","description":"Errors, what we hate but can\'t avoid. If you ever tried to debug an OpenCL program, you know how painful it is. However, SYCL offers C++ exception handling for host code, which is a bit of a blessing.","sidebar":"tutorialSidebar"},"sycl/first-step":{"id":"sycl/first-step","title":"First Step into SYCL","description":"This note book provides introduction to parallel programming. Because this book focuses more on the algorithmic aspects of parallel programming, we use SYCL instead of OpenCL or OpenMP because SYCL is a higher level programming model that is easier to understand and use.","sidebar":"tutorialSidebar"},"sycl/memory":{"id":"sycl/memory","title":"Memory","description":"In parallel computation, computation is important, but managing the data is as important. Think of taming a wild beast, feeding it is as important as controlling it.","sidebar":"tutorialSidebar"}}}}')}}]);