"use strict";(self.webpackChunknotes_template=self.webpackChunknotes_template||[]).push([[6266],{5343:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"nd-kernel/device-coarse-architecture","title":"Device Coarse Architecture","description":"Before introducing the ND kernel, we must take a look at how our devices work.","source":"@site/docs/nd-kernel/device-coarse-architecture.mdx","sourceDirName":"nd-kernel","slug":"/nd-kernel/device-coarse-architecture","permalink":"/parallel-programming-essentials/docs/nd-kernel/device-coarse-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/finger-bone/parallel-programming-essentials/blob/main/docs/nd-kernel/device-coarse-architecture.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"ND Kernel","permalink":"/parallel-programming-essentials/docs/category/nd-kernel"},"next":{"title":"Work Distribution","permalink":"/parallel-programming-essentials/docs/nd-kernel/work-distribution"}}');var i=n(4848),t=n(8453);const r={sidebar_position:1},o="Device Coarse Architecture",l={},c=[{value:"Command Queue",id:"command-queue",level:2},{value:"Computation Hierarchy",id:"computation-hierarchy",level:2},{value:"PE",id:"pe",level:3},{value:"Wavefront",id:"wavefront",level:3},{value:"Computation Unit",id:"computation-unit",level:3},{value:"Memory Hierarchy",id:"memory-hierarchy",level:2},{value:"Private Memory",id:"private-memory",level:3},{value:"Local Memory",id:"local-memory",level:3},{value:"Global Memory and Constant Global Memory",id:"global-memory-and-constant-global-memory",level:3}];function h(e){const a={admonition:"admonition",annotation:"annotation",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mrow:"mrow",p:"p",semantics:"semantics",span:"span",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"device-coarse-architecture",children:"Device Coarse Architecture"})}),"\n",(0,i.jsx)(a.p,{children:"Before introducing the ND kernel, we must take a look at how our devices work."}),"\n",(0,i.jsx)(a.h2,{id:"command-queue",children:"Command Queue"}),"\n",(0,i.jsx)(a.p,{children:"A command queue is a list of commands that are executed on a device. It is a queue of commands that are executed on a device. You can submit commands to the command queue to be executed on the device."}),"\n",(0,i.jsx)(a.h2,{id:"computation-hierarchy",children:"Computation Hierarchy"}),"\n",(0,i.jsx)(a.h3,{id:"pe",children:"PE"}),"\n",(0,i.jsx)(a.p,{children:"Processing elements (PE) are the basic units of computation on a device. They are the smallest units of computation that can be executed in parallel on a device. Each PE has its own registers and memory (the private memory). However, PEs doesn't have PC (program counter)."}),"\n",(0,i.jsx)(a.h3,{id:"wavefront",children:"Wavefront"}),"\n",(0,i.jsx)(a.admonition,{type:"info",children:(0,i.jsx)(a.p,{children:"Wavefront is the terminology for AMD GPU. For Nvidia GPU, it is called a warp. However, they are fundamentally the same."})}),"\n",(0,i.jsx)(a.admonition,{type:"tip",children:(0,i.jsx)(a.p,{children:"Typical values for a wavefront are 32 or 64 PEs."})}),"\n",(0,i.jsx)(a.p,{children:"A wavefront is a set of PEs that shares a clock-cycle. And every PEs in a wavefront stays synchronized."}),"\n",(0,i.jsx)(a.p,{children:"When performing memory access, the device does so in the unit of wavefront. Thus allowing optimizations like memory coalescing and broadcast."}),"\n",(0,i.jsx)(a.admonition,{type:"info",children:(0,i.jsx)(a.p,{children:"In earlier architectures, memory access is done in half-wavefront. But in modern architectures, memory access is done in wavefront."})}),"\n",(0,i.jsx)(a.h3,{id:"computation-unit",children:"Computation Unit"}),"\n",(0,i.jsx)(a.p,{children:"CU is a set of wavefront that holds a shared memory for all PEs. All PEs in a CU can cooperate with each other through shared memory."}),"\n",(0,i.jsx)(a.h2,{id:"memory-hierarchy",children:"Memory Hierarchy"}),"\n",(0,i.jsx)(a.h3,{id:"private-memory",children:"Private Memory"}),"\n",(0,i.jsx)(a.p,{children:"The memory each PE has is called private memory. It is very fast yet small, only accessible to the PE that owns it."}),"\n",(0,i.jsxs)(a.admonition,{type:"info",children:[(0,i.jsx)(a.p,{children:"We are talking about logical architecture. The physical architecture is different."}),(0,i.jsx)(a.p,{children:"In real GPU, it has a monolithic private memory bank that is distributed to each PE. However, different PE cannot access other's private memory."}),(0,i.jsx)(a.p,{children:"So it is also true for local memory."})]}),"\n",(0,i.jsx)(a.h3,{id:"local-memory",children:"Local Memory"}),"\n",(0,i.jsx)(a.p,{children:"The memory that is shared between PEs in a CU is called local memory. It is a bit slower than private memory, but can be accessed by all PEs in a CU."}),"\n",(0,i.jsx)(a.p,{children:"Local memory is made up by many banks, usually the same number as the PEs in a CU."}),"\n",(0,i.jsxs)(a.p,{children:["Banks are separated based on low-bit address. That is, assume we have ",(0,i.jsxs)(a.span,{className:"katex",children:[(0,i.jsx)(a.span,{className:"katex-mathml",children:(0,i.jsx)(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(a.semantics,{children:[(0,i.jsx)(a.mrow,{children:(0,i.jsx)(a.mi,{children:"n"})}),(0,i.jsx)(a.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,i.jsx)(a.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(a.span,{className:"base",children:[(0,i.jsx)(a.span,{className:"strut",style:{height:"0.4306em"}}),(0,i.jsx)(a.span,{className:"mord mathnormal",children:"n"})]})})]})," banks, for the address ",(0,i.jsxs)(a.span,{className:"katex",children:[(0,i.jsx)(a.span,{className:"katex-mathml",children:(0,i.jsx)(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(a.semantics,{children:[(0,i.jsx)(a.mrow,{children:(0,i.jsx)(a.mi,{children:"i"})}),(0,i.jsx)(a.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,i.jsx)(a.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(a.span,{className:"base",children:[(0,i.jsx)(a.span,{className:"strut",style:{height:"0.6595em"}}),(0,i.jsx)(a.span,{className:"mord mathnormal",children:"i"})]})})]}),", it goes to the ",(0,i.jsxs)(a.span,{className:"katex",children:[(0,i.jsx)(a.span,{className:"katex-mathml",children:(0,i.jsx)(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(a.semantics,{children:[(0,i.jsxs)(a.mrow,{children:[(0,i.jsx)(a.mi,{children:"i"}),(0,i.jsx)(a.mi,{mathvariant:"normal",children:"%"}),(0,i.jsx)(a.mi,{children:"n"})]}),(0,i.jsx)(a.annotation,{encoding:"application/x-tex",children:"i \\% n"})]})})}),(0,i.jsx)(a.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(a.span,{className:"base",children:[(0,i.jsx)(a.span,{className:"strut",style:{height:"0.8056em",verticalAlign:"-0.0556em"}}),(0,i.jsx)(a.span,{className:"mord mathnormal",children:"i"}),(0,i.jsx)(a.span,{className:"mord",children:"%"}),(0,i.jsx)(a.span,{className:"mord mathnormal",children:"n"})]})})]})," bank."]}),"\n",(0,i.jsx)(a.p,{children:"One bank can only handle one request at a time. Thus, if there are multiple PEs accessing the same bank, they have to wait for each other. This phenomenon is called bank conflict."}),"\n",(0,i.jsx)(a.h3,{id:"global-memory-and-constant-global-memory",children:"Global Memory and Constant Global Memory"}),"\n",(0,i.jsx)(a.p,{children:"They work the same as the name indicates. One thing you need to know is that it is very expensive to access global memory. Thus, you should avoid accessing global memory if possible."}),"\n",(0,i.jsx)(a.p,{children:"When we talked previously about memory accessing is done in the unit of wavefront, it is also true for global memory."}),"\n",(0,i.jsx)(a.p,{children:"However, because global memory accessing is expensive, the engineers have designed the memory controller in a way that, if you are accessing aligned, consecutive memory for a wavefront. Instead of fetching the data one by one, it fetches the whole chunk, and then distribute the data to each PEs. This is called memory coalescing."}),"\n",(0,i.jsx)(a.p,{children:"In addition, if multiple PEs are accessing the same location, they can be broadcasted to the same location. This is called broadcast."}),"\n",(0,i.jsx)(a.p,{children:"Global memory is the only memory accessible from the host."}),"\n",(0,i.jsxs)(a.admonition,{type:"info",children:[(0,i.jsx)(a.p,{children:"Bank conflict is unique to local memory."}),(0,i.jsx)(a.p,{children:"Broadcasting and memory coalescing is unique to global memory."}),(0,i.jsx)(a.p,{children:"Wavefront accessing pattern happens in both local memory and global memory."})]})]})}function m(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);