"use strict";(self.webpackChunknotes_template=self.webpackChunknotes_template||[]).push([[9888],{8622:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"sycl/memory","title":"Memory","description":"In parallel computation, computation is important, but managing the data is as important. Think of taming a wild beast, feeding it is as important as controlling it.","source":"@site/docs/sycl/memory.mdx","sourceDirName":"sycl","slug":"/sycl/memory","permalink":"/parallel-programming-essentials/docs/sycl/memory","draft":false,"unlisted":false,"editUrl":"https://github.com/finger-bone/parallel-programming-essentials/blob/main/docs/sycl/memory.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"First Step into SYCL","permalink":"/parallel-programming-essentials/docs/sycl/first-step"},"next":{"title":"Basic Kernel","permalink":"/parallel-programming-essentials/docs/sycl/basic-kernel"}}');var a=t(4848),i=t(8453);const s={sidebar_position:2},o="Memory",c={},l=[{value:"SYCL Memory Model",id:"sycl-memory-model",level:2},{value:"USM",id:"usm",level:3},{value:"Allocate and Free USM",id:"allocate-and-free-usm",level:3},{value:"Memory Transfer",id:"memory-transfer",level:2},{value:"Explicit data movement",id:"explicit-data-movement",level:3},{value:"Implicit data movement",id:"implicit-data-movement",level:3},{value:"USM transfer in Practice",id:"usm-transfer-in-practice",level:3},{value:"Buffer",id:"buffer",level:2},{value:"Buffer Creation",id:"buffer-creation",level:3},{value:"Buffer Accessors",id:"buffer-accessors",level:3},{value:"Buffer Copy",id:"buffer-copy",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"memory",children:"Memory"})}),"\n",(0,a.jsx)(n.p,{children:"In parallel computation, computation is important, but managing the data is as important. Think of taming a wild beast, feeding it is as important as controlling it."}),"\n",(0,a.jsx)(n.p,{children:"SYCL uses a very simple memory model that requires little detail into the hardware. If you ever learn OpenCL, you will know how complex real memory management can be. SYCL abstracts this complexity away, and provides a simple interface to manage memory."}),"\n",(0,a.jsx)(n.h2,{id:"sycl-memory-model",children:"SYCL Memory Model"}),"\n",(0,a.jsx)(n.h3,{id:"usm",children:"USM"}),"\n",(0,a.jsx)(n.p,{children:"SYCL use unified memory model that is called USM (Unified Shared Memory). USM is a memory model that allows the programmer to allocate memory that is accessible from both the host and the device. This memory model simplifies the programming model by removing the need to manage separate memory spaces for the host and device."}),"\n",(0,a.jsx)(n.p,{children:"USM has three types of memory that are all accessed via C++ pointers:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"usm::alloc::shared"})," memory is accessible from both the host and device and is shared between them. This memory is useful for data that is read and written by both the host and device."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"usm::alloc::device"})," memory is accessible only from the device and is used to store data that is only read and written by the device."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"usm::alloc::host"})," memory is accessible only from the host and is used to store data that is only read and written by the host."]}),"\n"]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Memory allocation types"}),(0,a.jsx)(n.th,{children:"Description"}),(0,a.jsx)(n.th,{children:"Host accessible"}),(0,a.jsx)(n.th,{children:"Device accessible"}),(0,a.jsx)(n.th,{children:"Location"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"host"}),(0,a.jsx)(n.td,{children:"allocated in host memory"}),(0,a.jsx)(n.td,{children:"yes"}),(0,a.jsx)(n.td,{children:"yes, remotely through PCIe or fabric link"}),(0,a.jsx)(n.td,{children:"host"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"device"}),(0,a.jsx)(n.td,{children:"allocated in device memory"}),(0,a.jsx)(n.td,{children:"no"}),(0,a.jsx)(n.td,{children:"yes"}),(0,a.jsx)(n.td,{children:"device"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"shared"}),(0,a.jsx)(n.td,{children:"allocated shared between host and device"}),(0,a.jsx)(n.td,{children:"yes"}),(0,a.jsx)(n.td,{children:"yes"}),(0,a.jsx)(n.td,{children:"dynamically migrate between host and device"})]})]})]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"A top of the three, SYCL provides buffer that further simplifies the code, which we will come into later. SYCL also provides image class, which is used to access image data. But since this note doesn't entail image processing, we will not go into the details of the image class."})}),"\n",(0,a.jsx)(n.h3,{id:"allocate-and-free-usm",children:"Allocate and Free USM"}),"\n",(0,a.jsxs)(n.p,{children:["To use host memory, just do what we usually do in C++, ",(0,a.jsx)(n.code,{children:"new"}),", ",(0,a.jsx)(n.code,{children:"delete"}),", or smart pointers, whatever you like."]}),"\n",(0,a.jsxs)(n.p,{children:["SYCL provides a unified, new ",(0,a.jsx)(n.code,{children:"malloc"})," and ",(0,a.jsx)(n.code,{children:"free"})," pair that can be used to allocate and free memory on the device."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"auto ptr = malloc<int>(N, q, usm::alloc::device);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This will allocate an array of ",(0,a.jsx)(n.code,{children:"N"})," integers on the device. The ",(0,a.jsx)(n.code,{children:"q"})," is the queue that the memory is allocated on. The ",(0,a.jsx)(n.code,{children:"usm::alloc::device"})," is the type of memory to allocate. The ",(0,a.jsx)(n.code,{children:"malloc"})," function returns a pointer to the allocated memory."]}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, to free the memory, use ",(0,a.jsx)(n.code,{children:"free"})," function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"free(ptr, q);\n"})}),"\n",(0,a.jsx)(n.p,{children:"But usually, for allocation, we use allocation function with the type of memory given, that is,"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"auto host_ptr = malloc_host<int>(N, q);\nauto device_ptr = malloc_device<int>(N, q);\nauto shared_ptr = malloc_shared<int>(N, q);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"memory-transfer",children:"Memory Transfer"}),"\n",(0,a.jsx)(n.p,{children:"We usually need to move the data from one type of memory to another, or to move the data from one device to another, there are two ways to do it."}),"\n",(0,a.jsx)(n.h3,{id:"explicit-data-movement",children:"Explicit data movement"}),"\n",(0,a.jsx)(n.p,{children:"Explicit data movement requires the programmer to manually copy data between different memories. For example, with a discrete accelerator, data must first be copied from host memory to accelerator memory before a kernel can use it. After the device computes the results, the data must be copied back to the host memory for use."}),"\n",(0,a.jsx)(n.p,{children:"The main advantage of explicit data movement is that the programmer has full control over when data is transferred, which is essential for optimizing performance by overlapping computation with data transfer."}),"\n",(0,a.jsx)(n.p,{children:"However, the drawback is that managing data movement can be tedious, error-prone, and time-consuming. Ensuring all data is transferred correctly and at the right time can be difficult and lead to incorrect results."}),"\n",(0,a.jsx)(n.h3,{id:"implicit-data-movement",children:"Implicit data movement"}),"\n",(0,a.jsx)(n.p,{children:"Implicit data movement, on the other hand, is handled by the parallel runtime or driver. The programmer does not have to manually manage data transfers; the runtime automatically ensures that data is transferred to the appropriate memory before use."}),"\n",(0,a.jsx)(n.p,{children:"The advantage of implicit data movement is that it simplifies development since the runtime handles the heavy lifting. This reduces the potential for errors in data transfers."}),"\n",(0,a.jsx)(n.p,{children:"However, the downside is that the programmer has less control over the behavior of the memory transfers. While this simplifies the porting of applications to new devices, in performance-critical sections, developers may replace implicit data movement with explicit data movement to optimize performance."}),"\n",(0,a.jsx)(n.h3,{id:"usm-transfer-in-practice",children:"USM transfer in Practice"}),"\n",(0,a.jsxs)(n.p,{children:["This part entails how we move the data within the USM. The key is to use ",(0,a.jsx)(n.code,{children:"h.memcopy"}),","]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"#include <array>\n#include <sycl/sycl.hpp>\nusing namespace sycl;\n\nconstexpr int N = 42;\n\nint main() {\n    queue q;\n    std::array<int, N> host_array;\n    int *device_array = malloc_device<int>(N, q);\n\n    // Initialize host_array\n    for (int i = 0; i < N; i++) {\n        host_array[i] = N;\n    }\n\n    // Copy host_array to device_array\n    q.submit([&](handler &h) {\n        h.memcpy(device_array, &host_array[0], N * sizeof(int));\n    });\n\n    q.wait();\n\n    // Increment values in device_array\n    q.submit([&](handler &h) {\n        h.parallel_for(N, [=](id<1> i) {\n            device_array[i]++; \n        });\n    });\n\n    q.wait();\n\n    // Copy device_array back to host_array\n    q.submit([&](handler &h) {\n        h.memcpy(&host_array[0], device_array, N * sizeof(int));\n    });\n\n    q.wait();\n\n    // Free device memory\n    free(device_array, q);\n\n    return 0;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"For implicit data movement, we just pretend as if everything is in the same memory, and the runtime will take care of the rest."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"#include <sycl/sycl.hpp>\nusing namespace sycl;\n\nconstexpr int N = 42;\n\nint main() {\n    queue q;\n\n    int *host_array = malloc_host<int>(N, q);\n    int *shared_array = malloc_shared<int>(N, q);\n\n    // Initialize host_array on host\n    for (int i = 0; i < N; i++) {\n        host_array[i] = i;\n    }\n\n    // We will learn how to simplify this example later\n    q.submit([&](handler &h) {\n        h.parallel_for(N, [=](id<1> i) {\n            // Access shared_array and host_array on device\n            shared_array[i] = host_array[i] + 1;\n        });\n    });\n\n    q.wait();\n\n    // Access shared_array on host\n    for (int i = 0; i < N; i++) {\n        host_array[i] = shared_array[i];\n    }\n\n    free(shared_array, q);\n    free(host_array, q);\n\n    return 0;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"buffer",children:"Buffer"}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.code,{children:"malloc"}),", ",(0,a.jsx)(n.code,{children:"free"})," and ",(0,a.jsx)(n.code,{children:"memcopy"}),", our need has been met. However, memory transfer is such a tedious and common task, so SYCL provides a buffer class that simplifies the memory management."]}),"\n",(0,a.jsx)(n.p,{children:"Buffers are a data abstraction that represent one or more objects of a given C++ type that satisfies device copyable concept."}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Concept is a very new feature in C++20. If you ever learnt typescript, concept is like interface in typescript. It is a way to define a set of rules that a type must satisfy- for example, having certain member functions, or being copyable."})}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"In std library, the device copyable containers are,"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::array<T, N>"})," if T is device copyable;"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::optional<T>"})," if T is device copyable;"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::pair<T1, T2>"})," if T1 and T2 are device copyable;"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::tuple<Types...>"})," if all the types in the parameter pack Types are device copyable;"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::variant<Types...>"})," if all the types in the parameter pack Types are device copyable;"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::basic_string_view<CharT, Traits>"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::span<ElementType, Extent>"})," (the std::span type has been introduced in C++20);"]}),"\n"]}),(0,a.jsxs)(n.p,{children:["Please note that ",(0,a.jsx)(n.code,{children:"std::vecor"})," is not device copyable."]})]}),"\n",(0,a.jsx)(n.p,{children:"Basically, you don't have to care about where your data is. You just create a buffer, then use different accessors to the same buffer."}),"\n",(0,a.jsx)(n.h3,{id:"buffer-creation",children:"Buffer Creation"}),"\n",(0,a.jsx)(n.p,{children:"To create buffer, use the construction method. It simply takes any object."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"buffer buf{host_data};\n"})}),"\n",(0,a.jsx)(n.p,{children:"Buffer is automatically dropped as the scope ends."}),"\n",(0,a.jsxs)(n.p,{children:["Alternatively, you can specify only the size of the buffer with the ",(0,a.jsx)(n.code,{children:"range"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"buffer buf(range{N});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Multidimensional buffer is allowed, but maximum dimension is three. You need to specify the type using this constructor."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"buffer<T> buf(range{N, N, N});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"buffer-accessors",children:"Buffer Accessors"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"host_accessor"})," takes only a buffer, the it can be used the same as array. But ",(0,a.jsx)(n.code,{children:"accessor"}),", which is actually the device accessor, needs an extra handler."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'#include <array>\n#include <sycl/sycl.hpp>\nusing namespace sycl;\n\nconstexpr int N = 42;\n\nint main()\n{\n    std::array<int, N> my_data;\n    for (int i = 0; i < N; i++)\n    {\n        my_data[i] = 0;\n    }\n\n    {\n        queue q;\n        buffer my_buffer(my_data);\n\n        q.submit([&](handler &h)\n                 {\n            // create an accessor to update the buffer on the device\n            accessor my_accessor(my_buffer, h);\n\n            h.parallel_for(N, [=](id<1> i) {\n                my_accessor[i]++; \n            }); });\n\n        // create host accessor\n        host_accessor host_accessor(my_buffer);\n\n        for (int i = 0; i < N; i++)\n        {\n            // access myBuffer on host\n            std::cout << host_accessor[i] << " ";\n        }\n        std::cout << "\\n";\n    }\n\n    // myData is updated when myBuffer is destroyed upon exiting scope\n    for (int i = 0; i < N; i++)\n    {\n        std::cout << my_data[i] << " ";\n    }\n    std::cout << "\\n";\n\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can also put access mode into the accessor, so that the SYCL runtime can better optimize the action graph (for example, two read only action can be executed in parallel)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"accessor{buffer, h, access_mode::read}\n"})}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Access Mode"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"read_only"}),(0,a.jsx)(n.td,{children:"Read-only access."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"write_only"}),(0,a.jsx)(n.td,{children:"Write-only access. Previous contents are not discarded in case of partial writes."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"read_write"}),(0,a.jsx)(n.td,{children:"Read and write access."})]})]})]}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"You can use in-order-queue that is guaranteed to execute the action graph in the same order as you create them,"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"queue q{property::queue::inorder()};\n"})}),(0,a.jsx)(n.p,{children:"By default, the queue is out of order for better performance."})]}),"\n",(0,a.jsx)(n.h3,{id:"buffer-copy",children:"Buffer Copy"}),"\n",(0,a.jsx)(n.p,{children:"To copy a buffer, just call,"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"q.submit([&](handler &h) {\n    h.copy(from, to);\n})\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Please note that the first parameter is the source, unlike ",(0,a.jsx)(n.code,{children:"mem_copy"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);